package leetcode.leetcode0830;

/**
 *
 * 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。
 *
 * 子数组 定义为原数组中的一个连续子序列。
 *
 * 请你返回 arr 中 所有奇数长度子数组的和 。
 *
 *  
 *
 * 示例 1：
 *
 * 输入：arr = [1,4,2,5,3]
 * 输出：58
 * 解释：所有奇数长度子数组和它们的和为：
 * [1] = 1
 * [4] = 4
 * [2] = 2
 * [5] = 5
 * [3] = 3
 * [1,4,2] = 7
 * [4,2,5] = 11
 * [2,5,3] = 10
 * [1,4,2,5,3] = 15
 * 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
 * 示例 2：
 *
 * 输入：arr = [1,2]
 * 输出：3
 * 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
 * 示例 3：
 *
 * 输入：arr = [10,11,12]
 * 输出：66
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class LeetCode0830_3 {
    /**
     * 事实上，我们可以统计任意只 arr[i]在奇数子数组的出现次数。
     * 对于原数组的任意位置 i 而言，其左边共有 i 个数，右边共有 n - i - 1 个数。
     * arr[i] 作为某个奇数子数组的成员的充要条件为：其所在奇数子数组左右两边元素个数奇偶性相同。
     * 于是问题转换为如何求得「arr[i] 在原数组中左边连续一段元素个为奇数的方案数」和「arr[i]在原数组右边连续一段元素个数为偶数的方案数」。
     * 由于我们已经知道 arr[i] 左边共有 i个数，右边共有 n - i - 1 个数，因此可以算得组合数：
     * 位置 i 左边奇数个数的方案数为 (i + 1) / 2右边奇数个数的方案数为 (n - i) / 2(n−i)/2；
     * 位置 i 右边偶数（非零）个数的方案数为 i / 2右边偶数（非零）个数的方案数为 (n - i - 1) / 2；
     * 考虑左右两边不选也属于合法的偶数个数方案数，因此在上述分析基础上对偶数方案数自增 1。
     * 至此，我们得到了位置 ii 左右奇数和偶数的方案数个数，根据「如果 arr[i]位于奇数子数组中，
     * 其左右两边元素个数奇偶性相同」以及「乘法原理」，我们知道 arr[i] 同出现在多少个奇数子数组中，再乘上 arr[i]即可
     * @param arr
     * @return
     */
    public int sumOddLengthSubarrays(int[] arr) {
        int n = arr.length;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int l1 = (i + 1) / 2, r1 = (n - i) / 2; // 奇数
            int l2 = i / 2, r2 = (n - i - 1) / 2; // 偶数
            // 当下标位0的时候左边是0个也要计数一次，所以要自增   考虑左右两边不选也属于合法的偶数个数方案数，因此在上述分析基础上对偶数方案数自增
            l2++; r2++;
            // 纵向思考每个元素都能出现他的子奇数数组中，所以 每个 当前元素*他的出现次数 求和 就是最总答案
            ans += (l1 * r1 + l2 * r2) * arr[i]; // 左奇数个数 * 右奇数个数 + 左偶数个数 * 又偶数个数 = 当前元素出现次数;
        }
        return ans;
    }

    public static void main(String[] args) {
        int[] arr = {1, 4, 2, 5, 3};
        LeetCode0830_3 lc = new LeetCode0830_3();
        System.out.println(lc.sumOddLengthSubarrays(arr));
    }
}
